# -*- coding: utf-8 -*-
"""H1D021010_Rizka Hasna_TSP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hm_T9L6KygFmnFnl9VrzqMnq2cSIGznh
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from tqdm import tqdm

# Node
node = np.random.randint(101, size=(20, 2))

# Plot nodes
for i in node:
    plt.scatter(i[0], i[1], c="b")
plt.axis([-5, 105, -5, 105])
plt.show()

#distance matrix
distance_matrix = np.zeros((len(node), len(node)))
for i in range(len(node)):
    for j in range(len(node)):
        distance_matrix[i][j] = np.linalg.norm(np.array((node[i][0], node[i][1])) - np.array((node[j][0], node[j][1])))

#algen
class GeneticAlgorithm:
    def __init__(self):
        self.population = []
        self.parent = []
        self.best = None
        self.best_log = []
        self.best_score_log = []
        self.best_routes_per_generation = []  # To store the best route of each generation

    def initialize(self, n_population, n_nodes):
        self.population = [np.random.permutation(n_nodes) for _ in range(n_population)]

    def get_objective_value(self, solution):
        objective = 0
        distance_list = [distance_matrix[solution[idx]][solution[idx+1]] for idx in range(len(solution)-1)]
        objective = sum(distance_list) + distance_matrix[solution[-1]][solution[0]]
        return objective

    def elitism(self, n_parent):
        self.parent = []
        fitness_population = {}
        for solution in self.population:
            fitness = self.get_objective_value(solution)
            fitness_population[fitness] = solution
        sorted_dict = sorted(fitness_population.items())

        self.best = sorted_dict[0][1]
        best_fitness = self.get_objective_value(self.best)
        self.best_log.append(self.best)
        self.best_score_log.append(best_fitness)

        # Store the best route of the current generation
        self.best_routes_per_generation.append(self.best)

        for sol_tuple in sorted_dict[:n_parent]:
            self.parent.append(sol_tuple[1])

    def tournament_selection(self, n_tournament):
        participants = random.sample(self.population, n_tournament)
        fitness_population = {}
        for solution in participants:
            fitness = self.get_objective_value(solution)
            fitness_population[fitness] = solution
        sorted_dict = sorted(fitness_population.items())
        winner = sorted_dict[0][1]
        return winner

    def crossover(self, parent1, parent2):
        # Partially Mapped Crossover (PMX)
        size = len(parent1)
        p1, p2 = [0]*size, [0]*size

        # Initialize position of each indices in the individuals
        for i in range(size):
            p1[parent1[i]] = i
            p2[parent2[i]] = i

        # Choose crossover points
        cxpoint1, cxpoint2 = sorted(random.sample(range(size), 2))

        # Apply crossover between cx points
        for i in range(cxpoint1, cxpoint2):
            # Keep track of the selected values
            temp1 = parent1[i]
            temp2 = parent2[i]
            parent1[i], parent1[p1[temp2]] = temp2, temp1
            parent2[i], parent2[p2[temp1]] = temp1, temp2
            # Position bookkeeping
            p1[temp1], p1[temp2] = p1[temp2], p1[temp1]
            p2[temp1], p2[temp2] = p2[temp2], p2[temp1]

        return parent1

    def mutation(self, solution):
        mutated_solution = np.copy(solution)
        idx1 = np.random.randint(len(mutated_solution))
        idx2 = np.random.randint(len(mutated_solution))

        while idx1 == idx2:
            idx2 = np.random.randint(len(mutated_solution))

        mutated_solution[[idx1, idx2]] = mutated_solution[[idx2, idx1]]
        return mutated_solution

    def genetic_algorithm(self, n_population, n_parent, n_nodes, n_tournament, p_crossover, p_mutation, max_generation):
        self.initialize(n_population, n_nodes)
        for gen in tqdm(range(max_generation)):
            self.elitism(n_parent)
            population = []

            while len(population) != n_population - len(self.parent):
                parent1 = self.tournament_selection(n_tournament)
                parent2 = self.tournament_selection(n_tournament)

                if p_crossover >= np.random.rand(1)[0]:
                    offspring = self.crossover(np.copy(parent1), np.copy(parent2))
                else:
                    random_parent = [parent1, parent2]
                    offspring = np.copy(random_parent[np.random.randint(len(random_parent))])

                if p_mutation >= np.random.rand(1)[0]:
                    offspring = self.mutation(offspring)

                population.append(offspring)

            population += self.parent
            self.population = population

        self.elitism(n_parent)

#fungsi membuat rute
def draw_route(solution, generation=None):
    for i in node:
        plt.scatter(i[0], i[1], c="b")
    for idx in range(len(solution)-1):
        plt.plot([node[solution[idx]][0],node[solution[idx+1]][0]], [node[solution[idx]][1],node[solution[idx+1]][1]], c="green")
    plt.plot([node[solution[-1]][0],node[solution[0]][0]], [node[solution[-1]][1],node[solution[0]][1]], c="green")
    plt.axis([-5, 105, -5, 105])
    if generation is not None:
        plt.title(f"Generation {generation}")
    plt.show()

#run algen
ga = GeneticAlgorithm()
ga.genetic_algorithm(100, 10, 20, 2, 0.9, 0.1, 50)

#plot rute terbaik setiap generasi
for gen, best_route in enumerate(ga.best_routes_per_generation):
    draw_route(best_route, gen)